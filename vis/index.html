<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Most Affordable Fitness Foods</title>
  <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&display=swap" rel="stylesheet">
  <style>
    :root {
      --main-dark: #333;
      --main-white: #fff;
    }

    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      font-family: 'Bebas Neue', sans-serif;
      background: var(--main-white);
      overflow: hidden; /* Prevent scrolling */
      display: flex; /* Responsive layout */
      flex-direction: column;
    }
    text {
      text-transform: uppercase;
      font-weight: bold;
      fill: var(--main-dark);
    }

    svg {
      width: 100vw; /* vw/vh: scaled to viewport */ 
      height: 90vh;
      display: block;
      font-size: 5vh;
      background-color: var(--main-dark);
    }
    h1 {
      height: 10vh;
      margin: 1vh 10vw 0.5vh;
      font-size: 5vh;
      text-align: right;
    }
    select {
      font-size: 3vh;
      vertical-align: middle;
      width: auto;
    }
  </style>
</head>

<body>
  <svg></svg>
  <h1>Foods by grams of <select id="category-select"> </select> per $ spent</h1>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
    // Rewrite stuff
    const mainDark = getComputedStyle(document.documentElement).getPropertyValue('--main-dark').trim();
    const mainWhite = getComputedStyle(document.documentElement).getPropertyValue('--main-white').trim();

    // I have no idea how this works but hey, it works :)
    const svg = d3.select("svg");
    let currentData = [];

    d3.json("supa_out.json").then(data => {
      currentData = data;

      const categories = Array.from(new Set(data.map(d => d.Category)));
      
      const select = d3.select("#category-select");
      select.append("option")
        .attr("value", "")
        .attr("disabled", true)
        .attr("selected", true)
        .text("Macro?");
      select.selectAll("option.category-option") // %% SOON: NON-ALPHABET ORDER
        .data(categories)
        .enter()
        .append("option")
        .classed("category-option", true)
        .text(d => d);
      select.on("change", render);

      //render(); // Initial render
    })

    function render() {
      const width = svg.node().getBoundingClientRect().width;
      const height = svg.node().getBoundingClientRect().height;

      svg.selectAll("*").remove();

      const category = d3.select("#category-select").property("value") || currentData[0].Category;

      // Data selection
      const filtered = currentData.filter(d => d.Category === category)
                          .sort((a, b) => b.Median - a.Median);
      // Y scale for vertical positions
      const yScale = d3.scaleBand()
                      .domain(filtered.map(d => d.Food))
                      .range([0, height]);
      // X scale for data values Q1 to Q3
      const xScale = d3.scaleLinear()
                      .domain([d3.min(filtered, d => d.Q1), d3.max(filtered, d => d.Q3)])
                      .range([0, width]);
      // Update height dynamically to fill entire 80vh vertically
      const itemHeight = height / filtered.length;

      const group = svg.append("g");

      // Draw the two strips per food item
      filtered.forEach(d => {
        const yTop = yScale(d.Food);
        const yCenter = yTop + itemHeight/2;

        // Coordinates and sizes for the two strips
        const x1 = xScale(d.Q1);
        const x2 = xScale(d.Median);
        const x3 = xScale(d.Q3);
        const gap = 0.005 * d3.min([height, width]);

        const stripHeight = itemHeight - 2*gap; // so the strips do not join the strips below
        const stripWidth1 = (x2 - x1) - 2*gap;
        const stripCenterX1 = (x1 + x2) / 2;
        const stripWidth2 = (x3 - x2) - 2*gap;
        const stripCenterX2 = (x2 + x3) / 2;

        // Create first strip (Q1 to Median)
        group.append("rect")
          .attr("x", x1 + gap)
          .attr("y", yTop + gap)
          .attr("width", stripWidth1)
          .attr("height", stripHeight)
          .attr("fill", mainWhite) // %% SOONNNN: paralllelogram

        // Create second strip (Median to Q3)
        group.append("rect")
          .attr("x", x2 + gap)
          .attr("y", yTop + gap)
          .attr("width", stripWidth2)
          .attr("height", stripHeight)
          .attr("fill", mainWhite);
          
        // Add food + median label to the sides
        group.append("text")
          .attr("x", x2 - gap)
          .attr("y", yCenter)
          .attr("dominant-baseline", "middle")
          .attr("text-anchor", "end")
          .attr("fill", mainDark)
          .attr("font-weight", "bold")
          .text(d.Food);

        group.append("text")
          .attr("x", x2 + gap)
          .attr("y", yCenter)
          .attr("dominant-baseline", "middle")
          .attr("text-anchor", "start")
          .attr("fill", mainWhite)
          .attr("font-weight", "bold")
          .text(d.Median.toFixed(1));
      });
    }

    // Re-render when screen is sized
    window.addEventListener("resize", () => {
      render(currentData);
    });
  </script>

</body>
</html>